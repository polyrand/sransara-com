<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><title>Build yourself a Git &mdash; sransara</title><link rel=stylesheet href=https://sransara.com/styles/main.min.css></head><body><main class="container leading-normal max-w-2xl mx-auto p-3"><div class="mb-6 text-sm font-mono"><span class="whitespace-no-wrap inline-block">/ <a class="underline text-blue-800 hover:text-blue-500" href=/>home/sransara</a></span>
<span class="whitespace-no-wrap inline-block">/ <a class="underline text-blue-800 hover:text-blue-500" href=/notes/>notes</a></span>
<span class="whitespace-no-wrap inline-block">/ <a class="underline text-blue-800 hover:text-blue-500" href=/notes/2019/>2019</a></span>
<span class="whitespace-no-wrap inline-block">/ $
<span class="text-gray-600 inline-block">cat /dev/urandom</span></span></div><h1 class="mb-2 text-5xl font-bold">Build yourself a Git</h1><span class="mb-2 text-gray-500 text-xs">Published
by <span class=text-gray-800>Samodya R. Abeysiriwardane</span>
on <span class=text-gray-800>Feb 28, 2019</span>
&nbsp;/&nbsp;<a class="underline text-blue-800 hover:text-blue-500" target=_blank rel="noopener noreferrer" href=https://github.com/sransara/sransara-com/tree/master/content/notes/2019/build-yourself-a-git/>Source</a>
&nbsp;/&nbsp;<a class="underline text-blue-800 hover:text-blue-500" href=https://sransara.com/notes/2019/build-yourself-a-git/>Permalink</a></span><hr class="my-2 border-2 border-gray-700"><div id=article class=asciidoc><div class=paragraph><p>Have you ever thought of building your own version control system?
In this not we will incrementally build a version control system while taking inspiration from Git.
Our focus will be on finding data structures to model revision lineage and version backups.</p></div><h3 id=id:tldr class=discrete>TLDR</h3><div class=paragraph><p>It’s all about the <a href=https://en.wikipedia.org/wiki/Directed_acyclic_graph target=_blank rel=noopener>directed acyclic graphs</a>, <a href=https://en.wikipedia.org/wiki/Persistent_data_structure target=_blank rel=noopener>fully persistent tries</a> and <a href=https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering target=_blank rel=noopener>layers of indirection</a> wrapped in <a href=https://en.wikipedia.org/wiki/Everything_is_a_file target=_blank rel=noopener>everything is a file</a>.</p></div><h3 id=id:disclaimer class=discrete>Disclaimer</h3><div class=paragraph><p>This note is neither intended as a Git usage or workflow guideline nor provide concrete code to make a binary compatible Git implementation.
But this note will have thought experiments and pseudocode sprinkled in to motivate the reasoning for data structure choices.
Consider this note an origin point for deeper rabbit holes to follow on implementation of distributed version control systems.</p></div><h3 id=id:tidbit class=discrete>Tidbit</h3><div class=paragraph><p>Have a look at Linus Torvalds' first <a href=https://github.com/git/git/tree/e83c5163316f89bfbde7d9ab23ca2e25604af290 target=_blank rel=noopener>commit</a> and the <a href=https://github.com/git/git/blob/e83c5163316f89bfbde7d9ab23ca2e25604af290/README target=_blank rel=noopener>README</a> of Git from 2005.
The fundamental data structures chosen at its inception has stood the test of time.</p></div><div id=toc class=toc><div id=toctitle class=title>Table of Contents</div><ul class=sectlevel1><li><a href=#id:what-is-a-version-control-system>1. What is a Version Control System?</a></li><li><a href=#id:sheep-following-git>2. Sheep following Git</a></li><li><a href=#id:intents-and-commands>3. Intents and commands</a></li><li><a href=#id:sheep-commit>4. sheep commit</a><ul class=sectlevel2><li><a href=#id:extending-the-commit-history-graph>4.1. Extending the commit history graph</a></li></ul></li><li><a href=#id:sheep-checkout-branch-and-heads>5. sheep checkout, branch and heads</a><ul class=sectlevel2><li><a href=#id:checkout>5.1. Checkout</a></li><li><a href=#id:branches>5.2. Branches</a></li></ul></li><li><a href=#id:decentralized-distributed-ness>6. Decentralized distributed-ness</a><ul class=sectlevel2><li><a href=#id:what-is-shared-between-the-repos>6.1. What is shared between the repos?</a></li><li><a href=#id:sheep-fetch-and-sheep-push>6.2. sheep fetch and sheep push</a></li><li><a href=#id:fetching-refs>6.3. Fetching refs</a></li><li><a href=#id:fetching-commit-objects>6.4. Fetching commit objects</a></li><li><a href=#id:the-content-addressable-storage>6.5. The content addressable storage</a></li><li><a href=#id:back-to-fetching>6.6. Back to: fetching</a></li></ul></li><li><a href=#id:back-to-sheep-commit>7. Back to: sheep commit</a><ul class=sectlevel2><li><a href=#id:revising-extend-commit-history-graph>7.1. Revising: Extend Commit History Graph</a></li><li><a href=#id:create-content-snapshot>7.2. Create content snapshot</a></li><li><a href=#id:trying-a-better-implementation-intuitive-attempt>7.3. Trying a better implementation: intuitive attempt</a></li></ul></li><li><a href=#id:sheep-add-and-the-staging-area>8. sheep add and the staging area</a></li><li><a href=#id:back-to-sheep-commit-2>9. Back to: sheep commit</a><ul class=sectlevel2><li><a href=#id:revised-create-content-snapshot>9.1. Revised: Create content snapshot</a></li></ul></li><li><a href=#id:sheep-diff-and-merge>10. sheep diff and merge</a><ul class=sectlevel2><li><a href=#id:diff>10.1. diff</a></li><li><a href=#id:merge>10.2. merge</a></li></ul></li><li><a href=#id:final-remarks>11. Final remarks</a><ul class=sectlevel2><li><a href=#id:birds-eye-view>11.1. Bird’s-eye view</a></li><li><a href=#id:conclusion>11.2. Conclusion</a></li></ul></li></ul></div><div class=quoteblock><blockquote>If you wish to make an apple pie from scratch, you must first invent the universe.</blockquote><div class=attribution>— Carl Sagan</div></div><div class=sect1><h2 id=id:what-is-a-version-control-system><a class=anchor href=#id:what-is-a-version-control-system></a>1. What is a Version Control System?</h2><div class=sectionbody><div class=paragraph><p>Before we get onto building a Version Control System (VCS), we need an idea of what we are trying to build.</p></div><div class=paragraph><p>We can view a VCS as a versioning backup system, that:</p></div><div class=ulist><ul><li><p>can keep the <strong>lineage</strong> of versions</p></li><li><p>can <strong>recover</strong>, <strong>compare</strong> and <strong>consolidate</strong> different versions</p></li></ul></div><div class=paragraph><p>In addition to these basics, a realworld VCS ought to be scalable in:</p></div><div class=ulist><ul><li><p>handling millions of lines of code</p></li><li><p>handling revisions from developers <strong>distributed</strong> around the globe</p></li></ul></div><div class=paragraph><p>Being the Linux kernel maintainer, this was certainly the requirements for Linus Torvalds in his implementation of a VCS, <strong><a href=https://en.wikipedia.org/wiki/Git target=_blank rel=noopener>Git</a></strong>.
Git takes capability for distributed workflow step further by providing a <strong>decentralized</strong> distributed workflow.</p></div><div class=paragraph><p>Another expectation from a VCS that can fall through the cracks is <strong>security</strong>.
But as stated <a href="https://marc.info/?l=git&m=118143549107708" target=_blank rel=noopener>in the Git mailing list thread</a>, security was part of the design goals from the beginning.</p></div><div class=ulist><ul><li><p>ability to prevent or detect corruption of data</p></li></ul></div></div></div><div class=sect1><h2 id=id:sheep-following-git><a class=anchor href=#id:sheep-following-git></a>2. Sheep following Git</h2><div class=sectionbody><div class=paragraph><p>Now that we have an rough idea of the requirements for what we are building, let’s get on to building this hypothetical VCS that I will call <code>sheep</code>, because this <code>sheep</code> will follow the path set by <strong>Git</strong>.</p></div><div class=paragraph><p>I need to clarify that <strong>Git may not be the be all end all of VCS</strong>.
But Git is the VCS with most steam behind it at the moment.
<a href=https://en.wikipedia.org/wiki/Mercurial target=_blank rel=noopener>Mercurial</a> is another VCS like Git that treats <em>snapshots</em> as first class citizens.
<a href=https://en.wikipedia.org/wiki/Darcs target=_blank rel=noopener>Darcs</a> and <a href=https://pijul.org/model/ target=_blank rel=noopener>Pijul</a> are other VCS that takes a different approach by utilizing <em>patches</em> as first citizens.</p></div></div></div><div class=sect1><h2 id=id:intents-and-commands><a class=anchor href=#id:intents-and-commands></a>3. Intents and commands</h2><div class=sectionbody><div class=paragraph><p>Unlike a versioned file system where content is automatically backed up;
in a VCS, all actions are performed when a user shows intent.
Therefore the interface to our VCS plays a crucial role.</p></div><div class=paragraph><p>Let’s first list essential user intents and map each of them to our UI.</p></div><h5 id=id:intent-to-initialize-a-directory-to-be-under-version-control class=discrete>Intent to initialize a directory to be under version control</h5><div class=ulist><ul><li><p><code>sheep init</code></p></li><li><p>Since this is the directory that user performs their work on: Git calls this the <strong>working directory</strong>. We will also create a ".sheep" directory to store the metadata and we will call that the <strong>repository</strong> (repo).</p></li></ul></div><h5 id=id:intent-to-include-the-changes-to-a-file-with-next-checkpoint class=discrete>Intent to include the changes to a file with next checkpoint</h5><div class=ulist><ul><li><p><code>sheep add &lt;file></code></p></li><li><p>Git calls this the <strong>staging area</strong>. Read more about it <a href=https://git-scm.com/book/en/v1/Getting-Started-Git-Basics target=_blank rel=noopener>here</a>. Only the changes that are staged will be included in the next checkpoint. Anything not staged will be considered as unchanged.</p></li></ul></div><h5 id=id:intent-to-make-a-new-checkpoint class=discrete>Intent to make a new checkpoint</h5><div class=ulist><ul><li><p><code>sheep commit</code></p></li><li><p>Here be dragons! Most of the magic happens in here.</p></li><li><p>When the user executes this command: a new backup version is created with all the staged content, and the version history is extended with the new checkpoint.
We will see more about this extensively later on.</p></li></ul></div><h5 id=id:intent-to-go-back-to-a-checkpoint-and-branch-out class=discrete>Intent to go back to a checkpoint and branch out</h5><div class=ulist><ul><li><p><code>sheep checkout &lt;checkpoint></code> and <code>sheep branch &lt;name></code></p></li></ul></div><div class=paragraph><p>Following image shows the basic Git (and hence Sheep) workflow, that essentially combines the above commands.</p></div><div id=image:git-basics-staging class=imageblock><div class=content><img src=git-basics-staging.png alt="git basics staging"></div><div class=title>Figure 1. Basic local Git workflow <a href=https://git-scm.com/book/en/v1/Getting-Started-Git-Basics target=_blank rel=noopener>from Git basics</a></div></div><h5 id=id:so-where-is-the-branching-work-flow class=discrete>So where is the branching work flow?</h5><div class=paragraph><p>It’s simply a matter of executing <code>sheep checkout &lt;checkpoint></code> to go back to a checkpoint; then <code>sheep branch &lt;name></code> to give the new branch a name.
And follow it up by <code>sheep add</code> and <code>sheep commit</code> workflow in <a href=#image:git-basics-staging>Figure 1</a>.
Later on we will see how this is handled internally.</p></div><div class=paragraph><p>There is few other important intents/commands (diff, merge, fetch, push) that we will discuss as we go along.</p></div></div></div><div class=sect1><h2 id=id:sheep-commit><a class=anchor href=#id:sheep-commit></a>4. sheep commit</h2><div class=sectionbody><div class=paragraph><p>From the implementation point of view, <code>commit</code> is where the magic happens.
As discussed earlier, user’s intent is to make a new checkpoint, which entails two ideas:</p></div><div class="olist arabic"><ol class=arabic><li><p>Make a backup of all directory content that is currently being tracked. Let’s call the view of the tracked directory content at a checkpoint to be <strong>snapshot</strong>.</p></li><li><p>Extend the version history graph with the information about this new checkpoint (and other metadata like author and date).</p></li></ol></div><div class=paragraph><p>We can notice the above two ideas are essentially two steps where step 2 is dependant on information provided by step 1.
Let’s give each step a name: by calling step 1 as 'create-content-snapshot' and step 2 as 'extend-commit-history-graph'.
Now we can view <code>commit</code> as the composition of two functions <code>create-content-snapshot</code> and <code>extend-commit-history-graph</code>.</p></div><div class=paragraph><p>There needs to be an interface for the two functions to compose.
Observe: all that’s need by <code>extend-commit-history-graph</code> is a way to find the snapshot created by <code>create-content-snapshot</code>.
See the <a href=#source:commit-code-outline>Listing 1</a> to see how this interfacing can be achieved using <strong>pointer-to-snapshot</strong>.</p></div><div id=source:commit-code-outline class=listingblock><div class=title>Listing 1. Outline of commit code</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>function</span> <span class=n>create</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>snapshot</span><span class=p>:</span>
   <span class=n>params</span><span class=p>:</span>   <span class=nb>dir</span><span class=o>-</span><span class=n>content</span>
   <span class=n>returns</span><span class=p>:</span>  <span class=n>pointer</span><span class=o>-</span><span class=n>to</span><span class=o>-</span><span class=n>snapshot</span>

<span class=n>function</span> <span class=n>extend</span><span class=o>-</span><span class=n>commit</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span><span class=p>:</span>
   <span class=n>params</span><span class=p>:</span>   <span class=n>commit</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span><span class=p>,</span> <span class=n>pointer</span><span class=o>-</span><span class=n>to</span><span class=o>-</span><span class=n>snapshot</span>
   <span class=n>returns</span><span class=p>:</span>  <span class=n>commit</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span>

<span class=c1># and then
</span><span class=n>commit</span> <span class=o>=</span> <span class=n>extend</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span><span class=p>(</span> <span class=p>...</span> <span class=p>,</span> <span class=n>create</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>snapshot</span><span class=p>(</span> <span class=p>...</span> <span class=p>)</span> <span class=p>)</span></code></pre></div></div><div class=paragraph><p>On each <code>commit</code>, <code>create-content-snapshot</code> function creates a new snapshot and feeds it to the <code>extend-commit-history-graph</code> function to create the extended commit history graph.</p></div><div class=paragraph><p>With the pieces of the commit puzzle in place, let’s start from the <code>extend-commit-history-graph</code> corner to see how everything will work.</p></div><div class=sect2><h3 id=id:extending-the-commit-history-graph><a class=anchor href=#id:extending-the-commit-history-graph></a>4.1. Extending the commit history graph</h3><div class=paragraph><p>Simple idea here is to keep track of the lineage of each commit.</p></div><div class=sect3><h4 id=id:commit><a class=anchor href=#id:commit></a>4.1.1. Commit</h4><div class=paragraph><p>In the previous section we discussed <code>commit</code> as a verb. Here we talk about commit as a noun.
From the previous section we know that a commit holds information about the snapshot.
Snapshot is a view of the directory content at a <code>commit</code>.
The goal of taking a snapshot is because we want to see all the changes to directory content after the parent commit.
We would also like to see who changed it, when they changed it, and why they changed it at a later point of time.</p></div><div class=paragraph><p>So to achieve this: think of a commit as a structure that holds (snapshot + parent commits + metadata: author, date and message).
We’ll call this a <strong>commit object</strong>.</p></div></div><div class=sect3><h4 id=id:commit-history-graph><a class=anchor href=#id:commit-history-graph></a>4.1.2. Commit history graph</h4><div class=paragraph><p>Commit History Graph is the data structure that holds the lineage information of every commit.
Basically it’s the life blood of our VCS.
In implementation, Commit history graph is just the relative ordering created by bunch of commit objects that connect to each other like a chain.</p></div></div><div class=sect3><h4 id=id:parent-and-child-commits><a class=anchor href=#id:parent-and-child-commits></a>4.1.3. Parent and Child commits</h4><div class=paragraph><p>Let’s look at two <code>sheep commit</code>s:</p></div><div class=listingblock><div class=title>Listing 2.</div><div class=content><pre class="rouge highlight"><code data-lang=bash>project/ <span class=nv>$ </span>sheep init
project/ <span class=nv>$ </span>vim README
project/ <span class=nv>$ </span>vim LICENSE
... &lt;removed commands <span class=k>for </span>brevity&gt; ...
project/ <span class=nv>$ </span>sheep commit <span class=nt>-a</span> <span class=nt>-m</span> <span class=s2>&#34;Initial&#34;</span>
...
project/ <span class=nv>$ </span>vim quake.c
project/ <span class=nv>$ </span>vim Makefile
... &lt;removed commands <span class=k>for </span>brevity&gt; ...
project/ <span class=nv>$ </span>sheep commit <span class=nt>-a</span> <span class=nt>-m</span> <span class=s2>&#34;Second&#34;</span></code></pre></div></div><div class=paragraph><p>And how they can be represented in the graph:</p></div><div id=image:commits-ab-0 class=imageblock><div class=content><img src=commits-ab-0.png alt="commits ab 0"></div><div class=title>Figure 2. First two commits in the Commit History</div></div><div class=paragraph><p>We’ll name the commits A, B in sequence for first and second commit.</p></div><div class=paragraph><p><strong>A points to B? Or B points to A?</strong>
Although we usually like to imagine the flow as forward in <em>time</em>, hence point from A to B;
the answer is B points to A, because what we want from the graph is the history that led to a commit.
We want to see the flow backwards in <em>time</em>.
This decision lets us easily traverse backwards in <em>time</em> to find the ancestors and hence the changes that led to the current state of a file.</p></div><div class=paragraph><p>Observe in this model that A has no knowledge of the existence of B, meaning that a parent commit keeps no knowledge of the children commits.
This allows us to remove, change and add children commits without mutating the parent commit.
Since past commits have no dependance on future commits: by definition the graph that is generated will be a <strong>Directed Acyclic Graph</strong> (DAG).</p></div></div><div class=sect3><h4 id=id:extending-history><a class=anchor href=#id:extending-history></a>4.1.4. Extending history</h4><div class=paragraph><p>Let’s put in few more commits to our history:</p></div><div id=image:commits-abcd-0 class=imageblock><div class=content><img src=commits-abcd-0.png alt="commits abcd 0"></div><div class=title>Figure 3. Linear commit history</div></div><div class=paragraph><p>Visually we can see that repo was at commit B, and then added commit C and then commit D.
In implementation this can simply be achieved by having a pointer that always point to the currently active commit.
Git calls this the <strong>HEAD</strong>.
On the above history, since our currently active commit is D, current value of HEAD will be D (This is not exactly how Git does it, there’s one extra level of indirection. We will see about this in the branching section).</p></div><div class=listingblock><div class=title>Listing 3.</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>define</span> <span class=n>function</span> <span class=n>extend</span><span class=o>-</span><span class=n>commit</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span><span class=p>:</span>
  <span class=c1># The current HEAD will be the parent commit for the new commit
</span>  <span class=n>p</span> <span class=o>=</span> <span class=n>get</span> <span class=n>value</span> <span class=n>at</span> <span class=n>HEAD</span>
  <span class=n>s</span> <span class=o>=</span> <span class=n>create</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>snapshot</span><span class=p>(...)</span>
  <span class=n>m</span> <span class=o>=</span> <span class=p>{</span> <span class=n>read</span> <span class=n>metadata</span> <span class=k>from</span> <span class=n>user</span> <span class=n>environment</span> <span class=p>}</span>
  <span class=n>c</span> <span class=o>=</span> <span class=n>create</span><span class=o>-</span><span class=n>new</span><span class=o>-</span><span class=n>commit</span><span class=o>-</span><span class=nb>object</span> <span class=k>with</span> <span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span>
  <span class=c1># give a unique name to &#39;c&#39; and save it in the repo (./sheep/objects/)
</span>  <span class=c1># now update HEAD to c (we will revise this last step later on)</span></code></pre></div></div><div class=paragraph><p>Now if we were to implement <code>sheep log</code>, it’s simply a matter of traversing the pointers towards the ancestors while logging the metadata information in the output.</p></div><div class=paragraph><p>Until now we have been looking at simple linear history.
Let’s see how branching can affect our commit implementation.</p></div></div></div></div></div><div class=sect1><h2 id=id:sheep-checkout-branch-and-heads><a class=anchor href=#id:sheep-checkout-branch-and-heads></a>5. sheep checkout, branch and heads</h2><div class=sectionbody><div class=sect2><h3 id=id:checkout><a class=anchor href=#id:checkout></a>5.1. Checkout</h3><div class=paragraph><p>Let’s say the user wants to go back to an old commit and try some new changes.
This where <code>checkout</code> comes in to play.</p></div><div class=paragraph><p>Let’s imagine a scenario: Commit C is a Long Term Support (LTS) release. And in it there’s a bug they want to fix.
To fix the bug user will just follow their intents.</p></div><div class=listingblock><div class=title>Listing 4.</div><div class=content><pre class="rouge highlight"><code data-lang=shell>project/ <span class=nv>$ </span><span class=c># user is at commit D now </span><i class=conum data-value=1></i><b>(1)</b>
project/ <span class=nv>$ </span>sheep checkout C <i class=conum data-value=2></i><b>(2)</b>
project/ <span class=nv>$ </span>vim <span class=nb>test</span>/main.c
project/ <span class=nv>$ </span>sheep commit <span class=nt>-a</span> <span class=nt>-m</span> <span class=s2>&#34;Update tests&#34;</span>
project/ <span class=nv>$ </span>vim quake.c
project/ <span class=nv>$ </span>vim CHANGELOG
project/ <span class=nv>$ </span>sheep commit <span class=nt>-a</span> <span class=nt>-m</span> <span class=s2>&#34;Fix super nasty bug&#34;</span> <i class=conum data-value=3></i><b>(3)</b></code></pre></div></div><div class=paragraph><p>In <a href=#image:commits-abcd-ef-0>Figure 4</a> we can see how it’s represented internally at each (1), (2), (3) instances above:</p></div><div id=image:commits-abcd-ef-0 class=imageblock><div class=content><img src=commits-abcd-ef-0.png alt="commits abcd ef 0"></div><div class=title>Figure 4. Checkout and extend</div></div><div class=paragraph><p>In implementation, <code>checkout</code> is simply to <strong>update the HEAD to a given commit</strong> and
<strong>recreate the directory content using the snapshot pointer</strong> in that commit.</p></div></div><div class=sect2><h3 id=id:branches><a class=anchor href=#id:branches></a>5.2. Branches</h3><h4 id=id:why-do-we-need-to-support-a-branching-workflow class=discrete>Why do we need to support a branching workflow?</h4><div class=paragraph><p>In <a href=#image:commits-abcd-ef-0>Figure 4</a> visually we can see the branch out at commit C.
We need to support this kind of workflow because not all changes are sequential. One of our goals from the first section was to: let contributors work independently without synchronization at every commit.
The system that we have discussed up to this point can already support a branching workflow.
Is there more to be done? Yes there is. But not much.</p></div><div class=paragraph><p>We can see that there are two branches that has D and F as their tips.
If the user wants to switch between the latest commit of each branch, with our current system they have to remember their exact commit name. But we can do better, with a simple layer of indirection.</p></div><div class=paragraph><p>Since our problem was that user has to remember the name of the commit at every branch tip:
we introduce a <strong>layer of indirection</strong>, that will <strong>point memorable names to commits</strong>.
In Git terms, this layer of indirection is called <strong>refs</strong>.</p></div><div class=paragraph><p>Branch names are just pointers to commits that follow along as the commit history graph extends.
In addition we can notice that HEAD concept we discussed before is almost too similar to this branch concept.
Git integrates the HEAD concept with the branches concept.
Internally Git calls local branches as <strong>heads</strong> with in refs.</p></div><div class=listingblock><div class=title>Listing 5.</div><div class=content><pre class="rouge highlight"><code data-lang=shell>project/ <span class=nv>$ </span>sheep checkout <span class=nt>-b</span> <span class=nv>$some</span><span class=nt>-branch-name</span>
project/ <span class=c># Updates the HEAD pointer to point</span>
project/ <span class=c>#    to a branch (a local head in refs) that points to a commit</span>
project/ <span class=c>#    ... and follow same procedure as before</span>
project/ <span class=nv>$ </span>&lt;... make some changes ...&gt;
project/ <span class=nv>$ </span>sheep commit <span class=nt>-a</span> <span class=nt>-m</span> <span class=s2>&#34;Super duper changes&#34;</span>
project/ <span class=c># Revise our pseudo function: extend-commit-history-graph so that it</span>
project/ <span class=c>#    looks at the HEAD and follows the pointer to the</span>
project/ <span class=c>#    branch which points to a commit.</span>
project/ <span class=c>#    Uses that value as the parent commit,</span>
project/ <span class=c>#    and update that value with the name of the new commit</span></code></pre></div></div><div id=image:commits-abcd-ef-1 class=imageblock><div class=content><img src=commits-abcd-ef-1.png alt="commits abcd ef 1"></div><div class=title>Figure 5. With branch heads</div></div><div class=paragraph><p>Heads or branches are the entry points to our commit-history-graph. That’s why in Git,
if you <code>git checkout &lt;random-commit></code>, it warns about <strong>detached head</strong>.
Unless you make a branch head at the detached head, any commits you make from a detached head will be lost in the sea of commits, as Git has no references to access them later.
Later on Git garbage collector will sweep off these detached commits (commits not accessible by any ref).</p></div></div></div></div><div class=sect1><h2 id=id:decentralized-distributed-ness><a class=anchor href=#id:decentralized-distributed-ness></a>6. Decentralized distributed-ness</h2><div class=sectionbody><div class=paragraph><p>Until now we have only focused on local operations and not focused about the Distributed-ness of our VCS.
That is because our plan is to have a symmetric view from the point of branches.
Simply put we view a remote repo as a namespaced collection of branches.</p></div><div class=paragraph><p>A main goal of branches was to enable parallel work that need not always be synchronized.
In that sense remote repo branch is just another branch to our local repo.</p></div><div class=paragraph><p>With this model of branching workflow we have set the roots for a decentralized distributed (version control) system.</p></div><div class=paragraph><p>Internally local branches are called <strong>heads</strong>, remote branches are called <strong>remotes</strong>.
And they are both handled as <strong>refs</strong>.</p></div><div class=sect2><h3 id=id:what-is-shared-between-the-repos><a class=anchor href=#id:what-is-shared-between-the-repos></a>6.1. What is shared between the repos?</h3><div class=paragraph><p>In the distributed world we do have to be careful about the shared data.
In our VCS the whole <strong>commit history graph is a globally shared data structure</strong>.</p></div><div class=paragraph><p>And hence:</p></div><div class=ulist><ul><li><p>commit objects and branch pointers</p></li><li><p>and also snapshot objects</p></li></ul></div><div class=paragraph><p>are shared.</p></div><div class=paragraph><p>As a globally shared data structure we want our <strong>commit history graph to be a <a href=https://en.wikipedia.org/wiki/Persistent_data_structure>persistent data structure</a></strong>.</p></div><div class=paragraph><p><strong>Why?</strong> Because if it was an ephemeral data structure we will need to complicate our implementation with synchronization primitives so that information about commits are not lost.
For a thorough explanation, <a href=https://www.infoq.com/presentations/Value-Values>watch "Value of values" by Rich Hikey</a>.</p></div><div class=paragraph><p>Immutable values aggregate to immutable values.
Since we want a persistent data structure, if we make <strong>commit objects and snapshot objects be immutable</strong>, the commit history graph will be an immutable persistent data structure as well.</p></div><div class=paragraph><p>We can be glad that the commit objects, that was discussed in the previous sections were not relying to be mutable.
In <code>extend-commit-history-graph</code> we create a new commit, and extend the graph with a new commit.</p></div><div class=paragraph><p>Note that the commit history graph is a <strong>fully persistent data structure</strong> (every version can be both accessed and modified) if we consider that commits are the entry points.
But, since we use the branch heads as the actual entry points and because branch heads are mutable, the commit history graph is just a bit away from being a fully persistent data structure.
Basically this means that we have no versioning for the commit history graph it self.
Read up on <code>git reflog</code> to see how Git tries to circumvent this.</p></div><div class=paragraph><p><strong>Are we still staying compatible with Git? I thought <code>git rebase</code> rewrites history.</strong>
Yes, we are still being compatible with Git.
Commands like <code>git commit --amend</code>, <code>git rebase</code> rewrites history by recreating the commits.
Using commit history from <a href=#image:commits-abcd-ef-1>Figure 5</a>, let’s see the end result of doing <code>rebase</code> hot-fix branch onto master branch.</p></div><div id=image:commits-abcd-ef-2 class=imageblock><div class=content><img src=commits-abcd-ef-2.png alt="commits abcd ef 2"></div><div class=title>Figure 6. After rebasing hot-fix on master</div></div><div class=paragraph><p>E<sub>2</sub> and F<sub>2</sub> is E and F respectively after being reapplied on the tip of master branch.
Since E and F becomes detached heads they will eventually be garbage collected.</p></div><div class=paragraph><p>It’s recommended to <strong>never do rebase on a public branch</strong> for the reason that we destructively update the branch pointer to a totally new branch, which can cause problems down the line when syncing back with the public.</p></div></div><div class=sect2><h3 id=id:sheep-fetch-and-sheep-push><a class=anchor href=#id:sheep-fetch-and-sheep-push></a>6.2. sheep fetch and sheep push</h3><div class=paragraph><p><code>fetch</code> and <code>push</code> are the commands that will show the users intent to synchronize.
On a fetch, we will fetched the commit history graph from a remote.
On a push, we will push our commit history graph to a remote.
Fetch needs read access and Push needs write access to the remote repo.</p></div><div class=paragraph><p>For simplicity let’s focus on <code>fetch</code>. Same concepts can be applied to <code>push</code> with slight variation.</p></div><div class=paragraph><p>Since we are aiming for a symmetrical view across remote and local repos: <code>fetch</code> will <em>download</em> all objects from the object stores (commit and snapshot) and refs without breaking any invariants on the destination repo.</p></div></div><div class=sect2><h3 id=id:fetching-refs><a class=anchor href=#id:fetching-refs></a>6.3. Fetching refs</h3><div class=paragraph><p>Fetching refs mean that we are getting all the entry points to the commit history graph in the remote repo.
Since these pointers are mutable we have to be careful on sync, so that we don’t lose information.
To prevent overwriting local heads, we sync remote refs with a namespace.
And then let the user merge in the remote content with the local content at their leisure.</p></div></div><div class=sect2><h3 id=id:fetching-commit-objects><a class=anchor href=#id:fetching-commit-objects></a>6.4. Fetching commit objects</h3><div class=paragraph><p>Collect all commit objects that are accessible from remote’s entry pont(s) and put them all with the commit objects currently on the local repo.
(Git takes an extra step here by compressing similar files called <strong>pack files</strong>, so that we transfer less over the network. But for <code>sheep</code> let’s ignore that for the sake of simplicity.)</p></div><div class=paragraph><p>To implement this we need to concretize some ideas that we glossed over during <code>extend-commit-history-graph</code>.</p></div></div><div class=sect2><h3 id=id:the-content-addressable-storage><a class=anchor href=#id:the-content-addressable-storage></a>6.5. The content addressable storage</h3><div class=paragraph><p>First we need a place for our commits to reside on the disk.
A database for our commit objects. And an api to get and create commits by a name.
Basically we need a <strong>key-value storage</strong>. Git following the true Unix ways, uses the file system structure.
Simply: filename as the key, and content as the value.</p></div><div class=paragraph><p>But remember that during a fetch we sync all commits from a remote repo into local repo.
That every commit should have its own unique name.
Looking at the problem in a different way: we need a way to see if a commit with same content already exists in the local repo.
Basically we need a way to uniquely identify each distinct piece of content.
How to easily check whether two contents are the same without having to scan the whole length of the content? Hashing!</p></div><div class=paragraph><p><strong>Content hashing</strong> to the rescue.
Get a hash of the object and that will be the name/key of that object and the value will be the object itself.
Git calls this the <strong>content addressable storage</strong> and resides in (.git/objects/)</p></div><div class=paragraph><p>As discussed before commit objects are immutable hence, there will be no destructive updates on the commit and hence no inconsistent keys.</p></div><div class=paragraph><p>If we use cryptographic hashing, we are able to attain the Security goal of Git from the top section.
By using <strong>cryptographic content hashing</strong> we are feeding two birds with one little grain.
Observe the similarities of our commit history graph to a <a href=https://en.wikipedia.org/wiki/Merkle_tree target=_blank rel=noopener>Merkle tree</a>.</p></div><div id=image:hash-tree class=imageblock><div class=content><img src=hash-tree.png alt="hash tree"></div><div class=title>Figure 7. Viewing Commit History DAG as a Merkle tree</div></div><div class=paragraph><p><a href=#image:hash-tree>Figure 7</a> shows that if an attacker tries to modify history by falsifying a commit (C2) they will end up creating a new branch out instead.
As long as 'a' and 'e' are different C2 and C2<sub>evil</sub> will have two different commit hashes.
By using a cryptographic hashing mechanism we can ensure that it will be hard for an attacker to falsify an 'e' that matches the hash with 'a'.
Implying that C3 and C3<sub>new</sub> will have different hashes.
So we can detect any corruption just by observing at the tip of the branch.</p></div></div><div class=sect2><h3 id=id:back-to-fetching><a class=anchor href=#id:back-to-fetching></a>6.6. Back to: fetching</h3><div class=paragraph><p>Now that we have the Content addressable storage, fetching commit objects is just a matter of downloading
all commits accessible from the remote branch access points on to the local repo.
Due to to our hashing mechanism we can ensure that we will not corrupt commit objects in the local repo.
(We assume that hash collisions are highly unlikely)</p></div><div class=paragraph><p>Once we have all the commit objects from the remote repo, we just use the remote refs (or remote branch pointers) to access the Commit History Graph that the remote repo sees.</p></div></div></div></div><div class=sect1><h2 id=id:back-to-sheep-commit><a class=anchor href=#id:back-to-sheep-commit></a>7. Back to: sheep commit</h2><div class=sectionbody><div class=paragraph><p>After a long detour we are back on track to our main command <code>sheep commit</code>.</p></div><div class=sect2><h3 id=id:revising-extend-commit-history-graph><a class=anchor href=#id:revising-extend-commit-history-graph></a>7.1. Revising: Extend Commit History Graph</h3><div class=paragraph><p>With the extra knowledge we gathered, we need to revise our algorithm for <code>extend-commit-history-graph</code> function.</p></div><div class=listingblock><div class=title>Listing 6.</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>define</span> <span class=n>function</span> <span class=n>extend</span><span class=o>-</span><span class=n>commit</span><span class=o>-</span><span class=n>history</span><span class=o>-</span><span class=n>graph</span><span class=p>:</span>
  <span class=c1># The current HEAD will be the parent commit for the new commit
</span>  <span class=c1># HEAD can either be a commit or a ref
</span>  <span class=k>if</span> <span class=n>HEAD</span> <span class=ow>is</span> <span class=n>a</span> <span class=n>branch</span> <span class=n>ref</span><span class=p>:</span>
    <span class=n>pc</span> <span class=o>=</span> <span class=n>get</span> <span class=n>value</span> <span class=n>at</span> <span class=n>branch</span> <span class=n>ref</span>
  <span class=k>else</span><span class=p>:</span>
    <span class=n>pc</span> <span class=o>=</span> <span class=n>get</span> <span class=n>value</span> <span class=n>at</span> <span class=n>HEAD</span>

  <span class=n>s</span> <span class=o>=</span> <span class=n>create</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>snapshot</span><span class=p>(...)</span>
  <span class=n>m</span> <span class=o>=</span> <span class=p>{</span> <span class=n>read</span> <span class=n>metadata</span> <span class=k>from</span> <span class=n>user</span> <span class=n>environment</span> <span class=p>}</span>
  <span class=n>c</span> <span class=o>=</span> <span class=n>create</span><span class=o>-</span><span class=n>new</span><span class=o>-</span><span class=n>commit</span><span class=o>-</span><span class=nb>object</span> <span class=k>with</span> <span class=p>(</span><span class=n>pc</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span>

  <span class=n>commit_name</span> <span class=o>=</span> <span class=n>crypto</span><span class=o>-</span><span class=nb>hash</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
  <span class=n>write</span><span class=o>-</span><span class=nb>file</span><span class=p>(</span><span class=n>directory</span><span class=o>=</span><span class=s>&#34;./sheep/objects/&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=o>=</span><span class=n>commit_name</span><span class=p>,</span> <span class=n>content</span><span class=o>=</span><span class=n>serialize</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>

  <span class=k>if</span> <span class=n>HEAD</span> <span class=ow>is</span> <span class=n>a</span> <span class=n>branch</span> <span class=n>ref</span><span class=p>:</span>
    <span class=n>update</span> <span class=n>the</span> <span class=n>value</span> <span class=n>of</span> <span class=n>branch</span> <span class=n>ref</span> <span class=n>to</span> <span class=o>--&gt;</span> <span class=n>commit_name</span>
  <span class=k>else</span><span class=p>:</span>
    <span class=n>update</span> <span class=n>the</span> <span class=n>value</span> <span class=n>of</span> <span class=n>HEAD</span> <span class=n>to</span> <span class=o>--&gt;</span> <span class=n>commit_name</span>

  <span class=k>return</span> <span class=n>commit_name</span></code></pre></div></div><div class=paragraph><p>Next up is implementing <code>create-content-snapshot</code>.</p></div></div><div class=sect2><h3 id=id:create-content-snapshot><a class=anchor href=#id:create-content-snapshot></a>7.2. Create content snapshot</h3><div class=paragraph><p>Let’s remind our selves what we need from this step:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>Make a backup of all directory content that is currently being tracked.</p></div></blockquote></div><div class=paragraph><p>Few important requirements for snapshot from the previous sections:</p></div><div class=ulist><ul><li><p>Need to provide a pointer to be used in a commit</p></li><li><p>Snapshots should be immutable: so that same commit does not point to different snapshot contents at different points of time</p></li></ul></div><div class=sect3><h4 id=id:naive-implementation><a class=anchor href=#id:naive-implementation></a>7.2.1. Naive implementation</h4><div class=listingblock><div class=title>Listing 7.</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>snapshot_name</span> <span class=o>=</span> <span class=n>create</span><span class=o>-</span><span class=n>unique</span><span class=o>-</span><span class=n>name</span><span class=o>-</span><span class=k>for</span><span class=o>-</span><span class=n>snapshot</span><span class=p>()</span>
<span class=n>create</span> <span class=n>directory</span> <span class=n>to</span> <span class=n>store</span> <span class=n>snapshot</span>
<span class=n>copy</span> <span class=nb>all</span> <span class=n>tracked</span> <span class=n>directory</span> <span class=n>content</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>repo</span> <span class=n>to</span> <span class=n>the</span> <span class=n>new</span> <span class=n>directory</span>
<span class=k>return</span> <span class=n>snapshot_name</span><span class=p>;</span> <span class=c1># to be used by extend-commit-history function</span></code></pre></div></div><div class=paragraph><p>We can reuse some concepts from the earlier section:</p></div><div class=ulist><ul><li><p>A snapshot is immutable: therefore we can use content hashing to help create a unique name</p></li><li><p>We already have a storage for content addressable storage where hash of the content is the key, so we can reuse the place that we used to store commits (<code>.sheep/objects/</code>)</p></li></ul></div><div class=paragraph><p>With that we can modify the naive implementation to be:</p></div><div class=listingblock><div class=title>Listing 8.</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>snapshot_name</span> <span class=o>=</span> <span class=n>get</span><span class=o>-</span><span class=n>total</span><span class=o>-</span><span class=nb>hash</span><span class=o>-</span><span class=n>of</span><span class=o>-</span><span class=n>the</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>being</span><span class=o>-</span><span class=n>tracked</span><span class=p>()</span>
<span class=n>create</span> <span class=n>directory</span> <span class=n>named</span> <span class=n>by</span> <span class=s>&#39;snapshot_name&#39;</span> <span class=ow>in</span> <span class=p>.</span><span class=o>/</span><span class=n>sheep</span><span class=o>/</span><span class=n>objects</span><span class=o>/</span>
<span class=n>copy</span> <span class=nb>all</span> <span class=n>tracked</span> <span class=n>directory</span> <span class=n>content</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>repo</span> <span class=n>to</span> <span class=n>the</span> <span class=n>new</span> <span class=n>directory</span>
<span class=k>return</span> <span class=n>snapshot_name</span><span class=p>;</span> <span class=c1># to be used by extend-commit-history function</span></code></pre></div></div><div class=paragraph><p>This is a fine implementation of the interface of <code>create-content-snapshot</code>.
And conceptually we are done with <code>sheep commit</code>.</p></div><div class=paragraph><p>But we can see that this naive method will cause <strong>excessive duplication</strong>, because in practice we expect there will be lot of common content between two different commits.
Since we make full backup of directory content with each backup we are not using space efficiently.</p></div></div></div><div class=sect2><h3 id=id:trying-a-better-implementation-intuitive-attempt><a class=anchor href=#id:trying-a-better-implementation-intuitive-attempt></a>7.3. Trying a better implementation: intuitive attempt</h3><div class=paragraph><p>The intuitive solution here is just store only the differences (diff).
When we say differences between the snapshots we need to focus on:</p></div><div class=ulist><ul><li><p>Differences in content (edits to file contents)</p></li><li><p>Differences in directory structure (add/remove directories)</p></li></ul></div><div class=paragraph><p>Let’s say we model the diff as a function that brings the parent commit’s snapshot to the child commit’s.
And store this function in some serialized format that we can apply later to reconstruct a version.
Space problem solved.
But this method has a major effect in performance for the user intent: going back to a previous revision.</p></div><div class=paragraph><p>Because to reconstruct a previous revision of a file we have to go back to it’s origin commit, and reapply all the differences down its lineage chain until the final version is constructed.
Essentially reconstruction per file becomes O(ND) time complexity where N is the length of the lineage chain and D is size of the diff (in worst case D is the size of the file itself).</p></div><div class=paragraph><p>This is an alright solution if we just want to archive, but we can do better for <code>sheep</code>.</p></div><div class=sect3><h4 id=id:better-implementation-just-like-git><a class=anchor href=#id:better-implementation-just-like-git></a>7.3.1. Better implementation: just like git</h4><div class=paragraph><p>To find a better way, we remind ourselves a property from the naive implementation.
The snapshot that got backed up (in to <code>.sheep/objects/&lt;hash></code>) is never going to be modified by another commit.
The <strong>snapshots are immutable</strong>.
Hence we can use a functional data structure to represent the snapshots, which opens up for the great deal of literature on implementations with much better space and time complexity than our naive implementation.
On that note <a href=https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf target=_blank rel=noopener>Purely Functional Data Structures by C. Okasaki</a> is a must read.</p></div></div><div class=sect3><h4 id=id:trying-a-trie><a class=anchor href=#id:trying-a-trie></a>7.3.2. Trying a trie</h4><div class=paragraph><p>We have to model our file system into a data structure.
For that if we view the file system as a key-value storage where the keys have a hierarchical structure, then the <a href=https://en.wikipedia.org/wiki/Trie>Trie</a> data structure naturally fits in as a data structure of choice.</p></div><div id=image:trying-trie class=imageblock><div class=content><img src=trying-trie.png alt="trying trie"></div><div class=title>Figure 8. Project directory tree on the left. Trie on the right.</div></div><div class=paragraph><p>In our implementation the project tree trie can be viewed as a recursive data structure:
<strong>a rooted tree</strong> where the tree can hold <strong>tree objects or blobs</strong>.
<strong>Tree object represents a directory</strong> and <strong>Blob represents a file</strong>.
Refer to <a href=https://git-scm.com/book/en/v2/Git-Internals-Git-Objects target=_blank rel=noopener>Git Objects</a> for further fine grained information.</p></div></div><div class=sect3><h4 id=id:fully-persistent-trie><a class=anchor href=#id:fully-persistent-trie></a>7.3.3. Fully persistent Trie</h4><div class=paragraph><p>In the project tree trie definition we came up with: "holds" can be thought of as "point to".
Most pointer based data structure like this can be made in to a persistent data structure by the <strong>path copying</strong> technique.
There are other techniques, but <code>sheep</code> will follow along with Git.
Few other reasons for using path copying:</p></div><div class=ulist><ul><li><p>Path copying stays consistent with the way we implement persistent Commit History Graph.</p></li><li><p>We will later see how it integrates back to the Security goal</p></li></ul></div><div class=paragraph><p>Read <a href=https://en.wikipedia.org/wiki/Persistent_data_structure target=_blank rel=noopener>here</a> for explanations on path copying and other techniques.</p></div><div class=paragraph><p>Path copying means we copy the path only for the values that changed.</p></div><div id=image:persistent-trie-0 class=imageblock><div class=content><img src=persistent-trie-0.png alt="persistent trie 0"></div><div class=title>Figure 9. Changing README file and adding game.py to V<sub>0</sub> snapshot leading to V<sub>1</sub> snapshot</div></div><div class=paragraph><p>In <a href=#image:persistent-trie-1>Figure 10</a> we can see that in V<sub>1</sub> snapshot has made a copy of the path to README because README file was changed in this snapshot.
Meanwhile "tests" directory and "setup.py" were kept as is, so those pointers are reused.</p></div><div class=paragraph><p>One more example to show off path copying in action:</p></div><div id=image:persistent-trie-1 class=imageblock><div class=content><img src=persistent-trie-1.png alt="persistent trie 1"></div><div class=title>Figure 10. Changing tests/camera.py file from V<sub>1</sub> snapshot leading to V<sub>2</sub> snapshot</div></div><div class=paragraph><p>As we can see this solves our duplication problem in <code>create-content-snapshot</code>, because we can reuse the pointer for any tree/blob objects that were not changed.</p></div></div><div class=sect3><h4 id=id:objects-and-pointers-of-the-trie><a class=anchor href=#id:objects-and-pointers-of-the-trie></a>7.3.4. Objects and Pointers of the trie</h4><div class=paragraph><p>To get the most reuse from our persistent trie we want granular objects.
As discussed before thinking directory as tree objects and files as blob objects gets us these granular objects.</p></div><div class=paragraph><p>Now we need a place to store these objects and the location can act as the pointer to our objects.
Remember that we need snapshots be immutable, hence the trie is immutable and therefore <strong>tree and blob objects are immutable</strong>.</p></div><div class=paragraph><p>This means we can reuse the same strategy that we used with commit objects.
That is to use the content addressable storage.
<strong>Key of a tree or blob will be the hash of its content</strong>.
Note that key of a blob is dependant only on the hash of its content, a rename would not affect the blob (This will help us track renames when doing <code>diff</code>).
Hash of the root of the trie will be the snapshot pointer that will be used in creating a commit object.</p></div><div class=paragraph><p><em>Notice</em>: that we are treating blobs as opaque objects.
We are not trying to store the diff between the blobs that could be almost the same, between revisions.
We are still not using our space as efficiently as possible.
This becomes an issue especially when we are transferring content over networks.
As briefly touched upon before, Git uses something called <strong>pack files</strong>, you can read more about it <a href=https://codewords.recurse.com/issues/three/unpacking-git-packfiles target=_blank rel=noopener>here</a>.</p></div><div class=paragraph><p>If we use cryptographic hashing as with commits: we get a <a href=https://en.wikipedia.org/wiki/Merkle_tree target=_blank rel=noopener>Merkle tree</a> at the snapshot level.
This means any change in content will be reflected as a new change leading to new a snapshot version.
Note that we are not able to stop someone from forcefully modifying the content inside an object.
But a simple integrity check by hash checking will let us identify offending objects.</p></div><div class=paragraph><p>As with commit objects: on a <code>sheep fetch</code> we can simply download all the tree/blob objects reachable from the remote commit history graph access point(s).</p></div></div><div class=sect3><h4 id=id:reducing-pointer-hops-with-a-cache-index><a class=anchor href=#id:reducing-pointer-hops-with-a-cache-index></a>7.3.5. Reducing pointer hops with a cache: index</h4><div class=paragraph><p>One downside of all these objects and pointers in the trie method is that, to see the latest committed version of a file we have to hop through all these pointers.
Since each pointer dereference consists of disk read, there will be a major performance hit.</p></div><div class=paragraph><p>To get solve this problem we will introduce a cache. Git calls this cache the <strong>index</strong>.
Whenever the user changes the current active commit: we will create the index, by fully traversing the trie snapshot associated with that commit and make a full list of paths seen by that commit.</p></div><div class=paragraph><p>This let’s us</p></div><div class=ulist><ul><li><p>Efficiently implement a command like <code>sheep status</code> similar to <code>git status</code>.</p></li><li><p>On a commit we can efficiently build up a snapshot trie by only copying the paths that have any changes.</p></li></ul></div><div class=paragraph><p>Linus' <a href=https://github.com/git/git/blob/e83c5163316f89bfbde7d9ab23ca2e25604af290/README#L125 target=_blank rel=noopener>README from the first commit</a> explains this concept thoroughly.</p></div><div class=paragraph><p>Later versions of Git combined the index as a cache with the staging area idea.</p></div></div></div></div></div><div class=sect1><h2 id=id:sheep-add-and-the-staging-area><a class=anchor href=#id:sheep-add-and-the-staging-area></a>8. sheep add and the staging area</h2><div class=sectionbody><div class=paragraph><p>During <code>create-content-snapshot</code> we glossed over the "content being tracked" part.
Since <code>sheep add</code> determines what content needs to be taken into a snapshot, let’s discuss this further.</p></div><div class=paragraph><p>First we need to remind ourselves the intent behind <code>sheep add</code>.</p></div><div class=quoteblock><blockquote><div class=paragraph><p>Intent to include the changes to a file/directory with next checkpoint</p></div></blockquote></div><div class=paragraph><p>This is a valid intent, because sometime we want to split the changes under different commits.
So the user only wants the changes in the staging area to be taken in to the snapshot with the next commit.</p></div><div class=paragraph><p>We can think of implementing <code>sheep add</code> as merely a way to set a marker for a file / directory entry in the index cache.
If they are new files we can also add those entries to the index as a different section.</p></div></div></div><div class=sect1><h2 id=id:back-to-sheep-commit-2><a class=anchor href=#id:back-to-sheep-commit-2></a>9. Back to: sheep commit</h2><div class=sectionbody><div class=sect2><h3 id=id:revised-create-content-snapshot><a class=anchor href=#id:revised-create-content-snapshot></a>9.1. Revised: Create content snapshot</h3><div class=paragraph><p><code>sheep add</code> combined with staging area (aka the index) greatly simplifies the job of <code>create-content-snapshot</code>.
Now we only need to check the entries marked in the 'index' to be included as changes in the snapshot.</p></div><div class=paragraph><p>Let’s write some pseudo code:</p></div><div class=listingblock><div class=title>Listing 9.</div><div class=content><pre class="rouge highlight"><code data-lang=python><span class=n>define</span> <span class=n>function</span> <span class=n>create</span><span class=o>-</span><span class=n>content</span><span class=o>-</span><span class=n>snapshot</span><span class=p>:</span>
  <span class=n>s</span> <span class=o>=</span> <span class=n>empty</span> <span class=n>tree</span>

  <span class=k>for</span> <span class=n>each</span> <span class=n>change</span> <span class=n>marked</span> <span class=n>on</span> <span class=n>the</span> <span class=n>index</span><span class=p>:</span>
    <span class=n>update</span> <span class=n>s</span> <span class=k>with</span> <span class=n>adding</span> <span class=n>the</span> <span class=n>path</span> <span class=n>by</span> <span class=n>looking</span> <span class=n>at</span> <span class=n>the</span> <span class=n>content</span> <span class=ow>in</span> <span class=n>working</span> <span class=nb>dir</span>
    <span class=n>store</span> <span class=n>the</span> <span class=n>new</span> <span class=n>objects</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>content</span> <span class=n>addressable</span> <span class=n>storage</span>

  <span class=k>for</span> <span class=n>each</span> <span class=nb>all</span> <span class=n>other</span> <span class=n>entries</span> <span class=n>on</span> <span class=n>the</span> <span class=n>index</span><span class=p>:</span>
    <span class=n>update</span> <span class=n>s</span> <span class=n>by</span> <span class=n>reusing</span> <span class=n>the</span> <span class=n>same</span> <span class=n>pointers</span>

  <span class=n>key</span> <span class=o>=</span> <span class=nb>hash</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
  <span class=n>include</span> <span class=n>this</span> <span class=n>key</span> <span class=ow>and</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>content</span> <span class=n>addressable</span> <span class=n>storage</span>

  <span class=n>update</span> <span class=n>the</span> <span class=n>index</span> <span class=n>so</span> <span class=n>that</span> <span class=nb>all</span> <span class=n>entries</span> <span class=n>are</span> <span class=n>marked</span> <span class=k>as</span> <span class=n>unchanged</span>

  <span class=k>return</span> <span class=n>the</span> <span class=n>key</span> <span class=c1># to be used when creating the new commit</span></code></pre></div></div><div class=paragraph><p>With the completion of <code>create-content-snapshot</code> we now have completed the full puzzle of sheep commit.</p></div></div></div></div><div class=sect1><h2 id=id:sheep-diff-and-merge><a class=anchor href=#id:sheep-diff-and-merge></a>10. sheep diff and merge</h2><div class=sectionbody><div class=paragraph><p>We have come to the last two commands that we had planned out for <code>sheep</code>.
Diff and merge are essential parts of a VCS, that actually needs note each for themselves.
For the time being we’ll <strong>briefly</strong> look at each and have pointers further reading.</p></div><div class=sect2><h3 id=id:diff><a class=anchor href=#id:diff></a>10.1. diff</h3><div class=paragraph><p>Diff is simply to diff two snapshots. Conceptually same as <strong>diffing two directories</strong>.
There are few minor optimizations we can make due to the usage of content addressing technique.
If we look at two hashes and they are the same then we can ignore having to diff.
This optimization can be done even at the tree / directory level because of the hash tree structure of the trie.</p></div><div class=paragraph><p>For easier diffing Git choses to store tree objects sort and store the pointer list.
This means that tree object diff will only be of O(n) worst case time complexity.
We have no way of controlling the blob diffs because the structure of that content is considered opaque from our VCS standpoint.</p></div><div class=quoteblock><blockquote><div class=paragraph><p>The first implementation simply leveraged the system diff executable via a call to popen in show-diff.c.
diff is a very famous and ubiquitous tool in the Linux world originally developed in the early 1970 for Unix.
Its first version used Hunt-McIlroy algorithm. The core algorithm was later notoriously improved thanks to the
work of Eugene W. Myers and Webb Miller, work extensively document in the papers: An O(ND) Difference Algorithm
and its Variations by Eugene W. Myers and A File Comparison Program by Webb Miller and Myers.</p></div></blockquote><div class=attribution>— E.W. Myers<br><cite>Algorithmica "An O(ND) difference algorithm and its variations" (1986)</cite></div></div><div class=paragraph><p>For the basic implementation we can just reuse the builtin Unix diff, but we have to keep in mind there’s whole big world of advance diff algorithms.</p></div></div><div class=sect2><h3 id=id:merge><a class=anchor href=#id:merge></a>10.2. merge</h3><div class=paragraph><p>If branching is yin. Merging is yang.
It doesn’t matter how much we can branch out, we need a way to consolidate these diverging changes.
And that is where merging comes in. For <code>sheep</code> will only focus on <a href=https://git-scm.com/docs/git-merge#_true_merge target=_blank rel=noopener>true merges</a> in this note.</p></div><div class=sect3><h4 id=id:user-intent><a class=anchor href=#id:user-intent></a>10.2.1. User intent</h4><div class=ulist><ul><li><p>Intent to merge diverged changes of a project in to one coherent result.</p></li><li><p><code>sheep merge &lt;b></code>: Merges branch b changes on to the current branch</p></li></ul></div></div><div class=sect3><h4 id=id:commit-history-graph-2><a class=anchor href=#id:commit-history-graph-2></a>10.2.2. Commit History Graph</h4><div class=paragraph><p>First let’s look at how a merge looks like in our commit history graph.</p></div><div id=image:commits-abcd-ef-g class=imageblock><div class=content><img src=commits-abcd-ef-g.png alt="commits abcd ef g"></div><div class=title>Figure 11. Merging 'hot-fix' on to 'master' branch. G is a merge commit.</div></div><div class=paragraph><p>G is a merge commit.
It’s special only in the sense that it has <strong>two parent commits</strong>.
Everything else that we know about commits apply here.</p></div></div><div class=sect3><h4 id=id:3-way-merge><a class=anchor href=#id:3-way-merge></a>10.2.3. 3 way merge</h4><div class=paragraph><p>For <code>sheep</code> will chose two do three way merge following the path of Git.
3-way merge has shown more success in performing automatic merges compared to 2-way merge.</p></div><div class=paragraph><p>3-way merge means, the user gets access to two conflicting pieces of content and the base content where they both were derived from.</p></div><div class=paragraph><p>Let’s see how to achieve this in <code>sheep merge</code> as seen on <a href=#image:commits-abcd-ef-g>Figure 11</a>.</p></div></div><div class=sect3><h4 id=id:lca><a class=anchor href=#id:lca></a>10.2.4. LCA</h4><div class=paragraph><p>We are trying to merge 'hot-fix' branch (commit F) into 'master' branch (commit D).
Visually we can see that commit C is the base commit that derived both F and D.
But more formally this commit C is defined as the <strong><a href=https://en.wikipedia.org/wiki/Lowest_common_ancestor>Lowest Common Ancestor</a> of the commit history DAG</strong>.</p></div><div class=quoteblock><blockquote><div class=paragraph><p>Naive algorithm for finding LCA:</p></div><div class="olist arabic"><ol class=arabic><li><p>Start at each of nodes you wish to find the lca for (a and b)</p></li><li><p>Create sets aSet containing a, and bSet containing b</p></li><li><p>If either set intersects with the union of the other sets previous values (i.e. the set of notes visited) then
that intersection is LCA. if there are multiple intersections then the earliest one added is the LCA.</p></li><li><p>Repeat from step 3, with aSet now the parents of everything in aSet, and bSet the parents of everything in bSet</p></li><li><p>If there are no more parents to descend to then there is no LCA</p></li></ol></div><div class=paragraph><p> — <a href=https://doi.org/10.1016/j.jalgor.2005.08.001>Lowest common ancestors in trees and directed acyclic graphs (2005)</a></p></div></blockquote></div><div class=paragraph><p>When there are crisscross merges involved, there can be multiple LCAs.
The default solution to this problem in Git is to do recursive LCA on these two until we find a single LCA.
See <a href=https://git-scm.com/docs/git-merge-base target=_blank rel=noopener>documentation for git-merge-base</a>.</p></div></div><div class=sect3><h4 id=id:trie-merge><a class=anchor href=#id:trie-merge></a>10.2.5. Trie merge</h4><div class=paragraph><p>Once we have a base commit and the two conflicting commits, we are ready to do the merge of directory content.</p></div><div class=paragraph><p>We can think of trie merge as a merge function for key value storage, because trie is basically a key value storage where keys have a hierarchy.</p></div><div class=paragraph><p>To investiage this let’s zoom in on commits C, D and F in <a href=#image:commits-abcd-ef-g>Figure 11</a>.
C is the common ancestor.
D is the current tip of <code>master</code> branch; F is the current tip of <code>hot-fix</code> branch.
Let’s see how the merged commit G can be derived from C, D and F.
I have used (*) stars to mark which content were actually changed from C.</p></div><div id=image:trie-merge class=imageblock><div class=content><img src=trie-merge.png alt="trie merge"></div><div class=title>Figure 12. View of the snapshots at commits C, D and F.</div></div><div class=paragraph><p>We do a diff of the C’s commit snapshot against D’s to see what has changed from C to D.
Then we do a diff of C’s commit snapshot against F’s to see what has changed from C to F.
These diff we will call <strong>patches</strong>. Now we use merge algorithm to auto merge content that never conflicted.</p></div><div class=paragraph><p>For example in <a href=#image:trie-merge>Figure 12</a>:</p></div><div class=ulist><ul><li><p>*1, *2 only changed on 'master' branch therefore we can <strong>auto merge</strong> these changes in to the final snapshot.</p></li><li><p>*5 only changed on the 'hot-fix' hence we can <strong>auto merge</strong> this change into the final snapshot as well.</p></li><li><p>*3 and *4 shows that README was changed in both branches: hence a conflict on that file.</p></li><li><p>Think about how we should handle auto merges for: deletes and renames</p></li></ul></div><div class=paragraph><p>At a conflict, <code>merge</code> will pause the merge and do a diff and put helper markers to identify the base, ours (current branch) and theirs (merging branch) changes.
Once the merge conflicts are resolved, merge will resume to make a commit with this new snapshot view and this commit will point to the two parent commits.</p></div><div class=imageblock><div class=content><img src=trie-merged.png alt="trie merged"></div><div class=title>Figure 13. View of the snapshots at the merged commit G.</div></div><div class=paragraph><p>Read into <a href=https://git-scm.com/docs/git-merge target=_blank rel=noopener>git merge documentation</a> to see the extra functionalities that it brings to the table.</p></div><div class=paragraph><p>With that we have reached the end of essential commands we planned out for <code>sheep</code>.</p></div></div></div></div></div><div class=sect1><h2 id=id:final-remarks><a class=anchor href=#id:final-remarks></a>11. Final remarks</h2><div class=sectionbody><div class=paragraph><p>Say no more to <code>rm -rf .git</code>. Say hello to <code>rm -rf .sheep</code>.</p></div><div class=sect2><h3 id=id:birds-eye-view><a class=anchor href=#id:birds-eye-view></a>11.1. Bird’s-eye view</h3><div class=paragraph><p>If we take a bird’s-eye view of what we have done until now: we can see that we have built a database.
A database with a branching based concurrency control mechanism.
Taking the notion of <strong>database as value</strong> (<a href="https://www.youtube.com/watch?v=EKdV1IgAaFc" target=_blank rel=noopener>talk by Rich Hikey</a>), the value we built for <code>sheep</code> is a <strong>trie</strong>.
But we focused on a trie merely because our aim was to build a VCS.
Using just content addressable storage and ref indirection layer as our building blocks we should be able to build almost any fully persistent data structure.
Mirage OS <a href=https://mirage.io/blog/introducing-irmin target=_blank rel=noopener>Irmin project</a> is an exploration of this idea.</p></div></div><div class=sect2><h3 id=id:conclusion><a class=anchor href=#id:conclusion></a>11.2. Conclusion</h3><div class=paragraph><p>In this note we managed to split Git and its concepts into manageable pieces so that we can build it from the ground up.
More importantly while building the concepts step by step, we tried to build up understanding by asking ourselves why at each step of the way.</p></div><div class=paragraph><p>If you are hungry for more VCS concepts: look into <a href=https://pijul.org/model/ target=_blank rel=noopener>Pijul</a>.</p></div><div class=quoteblock><blockquote><div class=paragraph><p>The main difference between Pijul and Git is that
Pijul deals with changes (or patches), whereas Git
deals only with snapshots (or versions).</p></div><div class=paragraph><p>There are several advantages to using patches.
First, patches are the intuitive atomic unit of work.
As such, they are easier to understand than commits.
And actually, Git users often reason in terms of patches,
displaying commits as differences between snapshots.</p></div><div class=paragraph><p>Patches can be merged according to intuitive formal axioms …​</p></div><div class=paragraph><p> — <a href=https://pijul.org/manual/why_pijul.html target=_blank rel=noopener>Pijul manual</a></p></div></blockquote></div></div></div></div></div></main><script>(function(){})();</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "7e685cdfbe6e496396ca70a124dadd1a"}'></script></body></html>